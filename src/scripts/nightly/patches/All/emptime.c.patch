diff --git a/include/emptime.h b/include/emptime.h
new file mode 100644
index 0000000..a83b29d
--- /dev/null
+++ b/include/emptime.h
@@ -0,0 +1,42 @@
+/*
+ *  Empire - A multi-player, client/server Internet based war game.
+ *  Copyright (C) 1986-2008, Dave Pare, Jeff Bailey, Thomas Ruschak,
+ *                           Ken Stevens, Steve McClure
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  ---
+ *
+ *  See files README, COPYING and CREDITS in the root of the source
+ *  tree for related information and legal notices.  It is expected
+ *  that future projects/authors will amend these files as needed.
+ *
+ *  ---
+ *
+ *  emptime.h: Time functions for regression testing and
+ *             replaying journals.
+ *
+ *  Known contributors to this file:
+ *     Ron Koenderink, 2008
+ */
+
+#ifndef EMPTIME_H
+#define EMPTIME_H
+
+#include <time.h>
+
+#define empire_time(expr) emp_time((expr), __FUNCTION__)
+extern time_t emp_time(time_t *, const char []);
+#endif
diff --git a/include/commands.h b/include/commands.h
index 594d263..0b22f09 100644
--- a/include/commands.h
+++ b/include/commands.h
@@ -34,6 +34,7 @@
 #ifndef COMMANDS_H
 #define COMMANDS_H
 
+#include "emptime.h"
 #include "file.h"
 #include "nat.h"
 #include "player.h"
diff --git a/src/lib/commands/buy.c b/src/lib/commands/buy.c
index 7e4daf0..6e244cf 100644
--- a/src/lib/commands/buy.c
+++ b/src/lib/commands/buy.c
@@ -170,7 +170,7 @@ buy(void)
     if (bid > 0.04 + comm.com_price) {
 	comm.com_price = bid;
 	/* Add five minutes to the time if less than 5 minutes */
-	time(&now);
+	empire_time(&now);
 	if (((MARK_DELAY - (now - comm.com_markettime)) < 300) &&
 	    comm.com_maxbidder != player->cnum) {
 	    comm.com_markettime += 300;
@@ -212,7 +212,7 @@ check_market(void)
     for (n = 0; getcomm(n, &comm); n++) {
 	if (comm.com_maxbidder == comm.com_owner || comm.com_owner == 0)
 	    continue;
-	(void)time(&now);
+	(void)empire_time(&now);
 	tleft = MARK_DELAY / 3600.0 - (now - comm.com_markettime) / 3600.0;
 	if (tleft < 0)
 	    tleft = 0;
diff --git a/src/lib/commands/coll.c b/src/lib/commands/coll.c
index 3fcb48f..2183d98 100644
--- a/src/lib/commands/coll.c
+++ b/src/lib/commands/coll.c
@@ -71,7 +71,7 @@ coll(void)
     }
     /* If we got here, we check to see if it's been defaulted on.  We
        already know it's owed to this player. */
-    owed = loan_owed(&loan, time(&now));
+    owed = loan_owed(&loan, empire_time(&now));
     if (now <= loan.l_duedate) {
 	pr("There has been no default on loan %d\n", arg);
 	return RET_FAIL;
@@ -124,7 +124,7 @@ coll(void)
 	caploss(&sect, loan.l_lonee, "that was %s's capital!\n");
     putsect(&sect);
     nreport(player->cnum, N_SEIZE_SECT, loan.l_lonee, 1);
-    owed = loan_owed(&loan, time(&now));
+    owed = loan_owed(&loan, empire_time(&now));
     if (pay >= owed) {
 	loan.l_status = LS_FREE;
 	loan.l_ldur = 0;
@@ -135,7 +135,7 @@ coll(void)
 	   xyas(sect.sct_x, sect.sct_y, loan.l_lonee), arg);
 	pr("That loan is now considered repaid.\n");
     } else {
-	(void)time(&loan.l_lastpay);
+	(void)empire_time(&loan.l_lastpay);
 	owed -= pay;
 	loan.l_amtdue = (long)owed;
 	pay += loan.l_amtpaid;
diff --git a/src/lib/commands/cons.c b/src/lib/commands/cons.c
index d67e64e..30d1ca1 100644
--- a/src/lib/commands/cons.c
+++ b/src/lib/commands/cons.c
@@ -229,7 +229,7 @@ loan_accept(struct ltcomstr *ltcp)
     putnat(lender);
     player->dolcost -= lp->l_amtdue;
     lp->l_amtpaid = 0;
-    (void)time(&lp->l_lastpay);
+    (void)empire_time(&lp->l_lastpay);
     lp->l_duedate = lp->l_ldur * 86400 + lp->l_lastpay;
     lp->l_status = LS_SIGNED;
     if (!putloan(ltcp->num, lp)) {
diff --git a/src/lib/commands/dump.c b/src/lib/commands/dump.c
index 3ad1f21..fa009f0 100644
--- a/src/lib/commands/dump.c
+++ b/src/lib/commands/dump.c
@@ -241,7 +241,7 @@ dump(void)
 
     if (player->god)
 	pr("   ");
-    time(&now);
+    empire_time(&now);
     pr("DUMP SECTOR %ld\n", (long)now);
     if (player->god)
 	pr("own ");
diff --git a/src/lib/commands/fina.c b/src/lib/commands/fina.c
index a6add31..e458c28 100644
--- a/src/lib/commands/fina.c
+++ b/src/lib/commands/fina.c
@@ -55,7 +55,7 @@ fina(void)
     }
     if (!snxtitem(&ni, EF_LOAN, "*", NULL))
 	return RET_SYN;
-    (void)time(&now);
+    (void)empire_time(&now);
     pr("\n");
     pr("             -= Empire Financial Status Report =- \n");
     pr("                  ");
diff --git a/src/lib/commands/flash.c b/src/lib/commands/flash.c
index 787e4a4..8517ccb 100644
--- a/src/lib/commands/flash.c
+++ b/src/lib/commands/flash.c
@@ -122,7 +122,7 @@ sendmessage(struct natstr *us, struct natstr *to, char *message, int verbose)
     int sent = 0;
     struct natstr *wto;
 
-    time(&now);
+    empire_time(&now);
     tm = localtime(&now);
     for (other = player_next(0); other != 0; other = player_next(other)) {
 	if (other->state != PS_PLAYING)
diff --git a/src/lib/commands/head.c b/src/lib/commands/head.c
index 2b1c148..e0ddb7a 100644
--- a/src/lib/commands/head.c
+++ b/src/lib/commands/head.c
@@ -66,7 +66,7 @@ head(void)
     struct nstr_item nstr;
     int i, n;
 
-    (void)time(&now);
+    (void)empire_time(&now);
     natp = getnatp(player->cnum);
     if (player->argp[1] != 0 && *player->argp[1] != 0) {
 	news_per = days(atoi(player->argp[1]));
diff --git a/src/lib/commands/ldump.c b/src/lib/commands/ldump.c
index 930810f..16dcf0c 100644
--- a/src/lib/commands/ldump.c
+++ b/src/lib/commands/ldump.c
@@ -157,7 +157,7 @@ ldump(void)
 
     if (player->god)
 	pr("   ");
-    time(&now);
+    empire_time(&now);
     pr("DUMP LAND UNITS %ld\n", (long)now);
     if (player->god)
 	pr("own ");
diff --git a/src/lib/commands/lost.c b/src/lib/commands/lost.c
index ad76e59..c302f21 100644
--- a/src/lib/commands/lost.c
+++ b/src/lib/commands/lost.c
@@ -51,7 +51,7 @@ lost(void)
 
     prdate();
     nlost = 0;
-    time(&now);
+    empire_time(&now);
     pr("DUMP LOST ITEMS %ld\n", (long)now);
     if (player->god)
 	pr("owner ");
diff --git a/src/lib/commands/mark.c b/src/lib/commands/mark.c
index f857444..6ec322d 100644
--- a/src/lib/commands/mark.c
+++ b/src/lib/commands/mark.c
@@ -74,7 +74,7 @@ pr_mark(struct comstr *comm)
     time_t now;
     double tleft;
 
-    (void)time(&now);
+    (void)empire_time(&now);
     tleft = MARK_DELAY / 3600.0 - (now - comm->com_markettime) / 3600.0;
     if (tleft < 0.0)
 	tleft = 0.0;
diff --git a/src/lib/commands/ndump.c b/src/lib/commands/ndump.c
index 927db4f..d081d13 100644
--- a/src/lib/commands/ndump.c
+++ b/src/lib/commands/ndump.c
@@ -50,7 +50,7 @@ ndump(void)
     prdate();
     if (player->god)
 	pr("   ");
-    time(&now);
+    empire_time(&now);
     pr("DUMP NUKES %ld\n", (long)now);
     if (player->god)
 	pr("own ");
diff --git a/src/lib/commands/news.c b/src/lib/commands/news.c
index 0095170..e365be2 100644
--- a/src/lib/commands/news.c
+++ b/src/lib/commands/news.c
@@ -65,7 +65,7 @@ news(void)
 	return RET_SYN;
     memset(page_has_news, 0, sizeof(page_has_news));
     memset(sectors_taken, 0, sizeof(sectors_taken));
-    (void)time(&now);
+    (void)empire_time(&now);
     natp = getnatp(player->cnum);
     then = natp->nat_newstim;
     if (player->argp[1]) {
diff --git a/src/lib/commands/offe.c b/src/lib/commands/offe.c
index 01570b5..01c40c6 100644
--- a/src/lib/commands/offe.c
+++ b/src/lib/commands/offe.c
@@ -127,7 +127,7 @@ do_treaty(void)
 	pr("Bad treaty duration.\n");
 	return RET_SYN;
     }
-    (void)time(&now);
+    (void)empire_time(&now);
     snxtitem_all(&nstr, EF_TREATY);
     while (nxtitem(&nstr, &trty)) {
 	if (trty.trt_status == TS_FREE) {
@@ -228,7 +228,7 @@ do_loan(void)
     loan.l_ldur = MIN(dur, 127);
     loan.l_amtpaid = 0;
     loan.l_amtdue = amt;
-    (void)time(&loan.l_lastpay);
+    (void)empire_time(&loan.l_lastpay);
     loan.l_duedate = loan.l_ldur * SECS_PER_DAY + loan.l_lastpay;
     if (!putloan(nstr.cur, &loan)) {
 	logerror("do_loan: can't save loan");
diff --git a/src/lib/commands/pdump.c b/src/lib/commands/pdump.c
index 48f0f4d..51578b1 100644
--- a/src/lib/commands/pdump.c
+++ b/src/lib/commands/pdump.c
@@ -119,7 +119,7 @@ pdump(void)
 
     if (player->god)
 	pr("   ");
-    time(&now);
+    empire_time(&now);
     pr("DUMP PLANES %ld\n", (long)now);
     if (player->god)
 	pr("own ");
diff --git a/src/lib/commands/play.c b/src/lib/commands/play.c
index a4ab28a..eb5c9f6 100644
--- a/src/lib/commands/play.c
+++ b/src/lib/commands/play.c
@@ -96,7 +96,7 @@ play_list(struct player *joe)
 	}
     }
 
-    time(&now);
+    empire_time(&now);
     pr("%-9.9s %3d %32.32s %2d:%02d %4lds",
        cname(joe->cnum),
        joe->cnum,
diff --git a/src/lib/commands/powe.c b/src/lib/commands/powe.c
index 2367002..74cf745 100644
--- a/src/lib/commands/powe.c
+++ b/src/lib/commands/powe.c
@@ -87,7 +87,7 @@ powe(void)
 		pr("\n  power new is disabled, using the last report.\n\n");
 	    else {
 		gen_power(powbuf, save);
-		pow_time = time(NULL);
+		pow_time = empire_time(NULL);
 		power_generated = 1;
 	    }
 	}
diff --git a/src/lib/commands/rea.c b/src/lib/commands/rea.c
index 5de2bb2..f9d7c71 100644
--- a/src/lib/commands/rea.c
+++ b/src/lib/commands/rea.c
@@ -76,7 +76,7 @@ rea(void)
     int readit;
     int may_delete = 1; /* may messages be deleted? */
 
-    now = time(NULL);
+    now = empire_time(NULL);
 
     if (*player->argp[0] == 'w') {
 	kind = "announcement";
@@ -188,7 +188,7 @@ rea(void)
 		(void)fflush(telfp);
 		(void)fseek(telfp, (long)size, SEEK_SET);
 		size = filelen;
-		now = time(NULL);
+		now = empire_time(NULL);
 		goto more;
 	    }
 	    if (*kind == 'a') {
diff --git a/src/lib/commands/repa.c b/src/lib/commands/repa.c
index 77a4734..c9b4079 100644
--- a/src/lib/commands/repa.c
+++ b/src/lib/commands/repa.c
@@ -76,7 +76,7 @@ repa(void)
     if (payment <= 0)
 	return RET_SYN;
 
-    newdue = (long)ceil(loan_owed(&loan, time(&now)) - payment);
+    newdue = (long)ceil(loan_owed(&loan, empire_time(&now)) - payment);
     if (newdue < 0) {
 	pr("You don't owe that much.\n");
 	return RET_FAIL;
diff --git a/src/lib/commands/rese.c b/src/lib/commands/rese.c
index bfb64d2..7ffcf5d 100644
--- a/src/lib/commands/rese.c
+++ b/src/lib/commands/rese.c
@@ -131,7 +131,7 @@ rese(void)
 	return RET_OK;
     }
     comm.com_price = price;
-    (void)time(&now);
+    (void)empire_time(&now);
     comm.com_markettime = now;
     if (!putcomm(number_set, &comm)) {
 	pr("Problems with the commodities file, Call the Deity\n");
diff --git a/src/lib/commands/sdump.c b/src/lib/commands/sdump.c
index 95899e5..f52bcb9 100644
--- a/src/lib/commands/sdump.c
+++ b/src/lib/commands/sdump.c
@@ -143,7 +143,7 @@ sdump(void)
 
     if (player->god)
 	pr("   ");
-    time(&now);
+    empire_time(&now);
     pr("DUMP SHIPS %ld\n", (long)now);
     if (player->god)
 	pr("own ");
diff --git a/src/lib/commands/sell.c b/src/lib/commands/sell.c
index e6ad4ea..78dd5fc 100644
--- a/src/lib/commands/sell.c
+++ b/src/lib/commands/sell.c
@@ -143,7 +143,7 @@ sell(void)
 	    if (comm.com_owner == 0)
 		break;
 	}
-	(void)time(&now);
+	(void)empire_time(&now);
 	ef_blank(EF_COMM, ii, &comm);
 	comm.com_type = ip->i_uid;
 	comm.com_owner = player->cnum;
diff --git a/src/lib/commands/set.c b/src/lib/commands/set.c
index dcda303..e93d7ba 100644
--- a/src/lib/commands/set.c
+++ b/src/lib/commands/set.c
@@ -130,7 +130,7 @@ set(void)
 	    trade.trd_owner = player->cnum;
 	    trade.trd_unitid = ni.cur;
 	    trade.trd_price = price;
-	    (void)time(&now);
+	    (void)empire_time(&now);
 	    trade.trd_markettime = now;
 	    trade.trd_maxbidder = player->cnum;
 	    puttrade(id, &trade);
diff --git a/src/lib/commands/shark.c b/src/lib/commands/shark.c
index ec38b3c..bc4af9a 100644
--- a/src/lib/commands/shark.c
+++ b/src/lib/commands/shark.c
@@ -72,7 +72,7 @@ shark(void)
 	return RET_FAIL;
     }
     /* If we got here, we check to see if it's been defaulted on. */
-    owed = loan_owed(&loan, time(&now));
+    owed = loan_owed(&loan, empire_time(&now));
     if (now <= loan.l_duedate) {
 	pr("There has been no default on loan %d\n", arg);
 	return RET_FAIL;
diff --git a/src/lib/commands/trad.c b/src/lib/commands/trad.c
index 5b0af58..e3a440b 100644
--- a/src/lib/commands/trad.c
+++ b/src/lib/commands/trad.c
@@ -97,7 +97,7 @@ trad(void)
 	    continue;
 	};
 	pr(" %3d ", ni.cur);
-	(void)time(&now);
+	(void)empire_time(&now);
 	tleft =
 	    TRADE_DELAY / 3600.0 - (now - trade.trd_markettime) / 3600.0;
 	if (tleft < 0.0)
@@ -252,7 +252,7 @@ trad(void)
     }
     if (bid > trade.trd_price) {
 	/* Add five minutes to the time if less than 5 minutes left. */
-	time(&now);
+	empire_time(&now);
 	if (((TRADE_DELAY - (now - trade.trd_markettime)) < 300) &&
 	    trade.trd_maxbidder != player->cnum)
 	    trade.trd_markettime += 300;
@@ -306,7 +306,7 @@ check_trade(void)
 	if (trade.trd_owner == trade.trd_maxbidder)
 	    continue;
 
-	(void)time(&now);
+	(void)empire_time(&now);
 	tleft =
 	    TRADE_DELAY / 3600.0 - (now - trade.trd_markettime) / 3600.0;
 	if (tleft < 0.0)
diff --git a/src/lib/commands/turn.c b/src/lib/commands/turn.c
index 640cef8..d5d9c19 100644
--- a/src/lib/commands/turn.c
+++ b/src/lib/commands/turn.c
@@ -74,7 +74,7 @@ turn(void)
     else
 	pr("Enter a new message of the day.\n");
 
-    time(&tgm.tel_date);
+    empire_time(&tgm.tel_date);
     tgm.tel_length = getele("The World", msgbuf);
     if (tgm.tel_length < 0) {
 	pr("Ignored\n");
diff --git a/src/lib/commands/upda.c b/src/lib/commands/upda.c
index 3ba68a1..0508a63 100644
--- a/src/lib/commands/upda.c
+++ b/src/lib/commands/upda.c
@@ -50,7 +50,7 @@ upda(void)
     if (updates_disabled())
 	pr("UPDATES ARE DISABLED!\n");
 
-    (void)time(&now);
+    (void)empire_time(&now);
     next = update_time[0];
     if (next) {
 	pr("\nUpdates occur at times specified by the ETU rates.\n\n");
diff --git a/src/lib/commands/vers.c b/src/lib/commands/vers.c
index 6e618c0..9e90299 100644
--- a/src/lib/commands/vers.c
+++ b/src/lib/commands/vers.c
@@ -54,7 +54,7 @@ vers(void)
 {
     time_t now;
 
-    (void)time(&now);
+    (void)empire_time(&now);
     pr("%s\n\n", version);
     pr("The following parameters have been set for this game:\n");
     pr("World size is %d by %d.\n", WORLD_X, WORLD_Y);
diff --git a/src/lib/common/file.c b/src/lib/common/file.c
index 8b0962f..e289f2f 100644
--- a/src/lib/common/file.c
+++ b/src/lib/common/file.c
@@ -40,6 +40,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
+#include "emptime.h"
 #include "file.h"
 #include "match.h"
 #include "misc.h"
@@ -424,7 +425,7 @@ do_write(struct empfile *ep, void *buf, int id, int count)
 	return -1;
 
     if (ep->flags & EFF_TYPED) {
-	now = ep->flags & EFF_NOTIME ? (time_t)-1 : time(NULL);
+	now = ep->flags & EFF_NOTIME ? (time_t)-1 : empire_time(NULL);
 	for (i = 0; i < count; i++) {
 	    /*
 	     * TODO Oopses here could be due to bad data corruption.
diff --git a/src/lib/common/game.c b/src/lib/common/game.c
index 0800d62..48c5401 100644
--- a/src/lib/common/game.c
+++ b/src/lib/common/game.c
@@ -44,6 +44,7 @@
 #include <config.h>
 
 #include <math.h>
+#include "emptime.h"
 #include "file.h"
 #include "game.h"
 #include "optlist.h"
@@ -81,7 +82,7 @@ game_note_bsanct(void)
     struct gamestr *game = getgamep();
 
     if (game->game_rt == 0) {
-	game->game_rt = time(NULL);
+	game->game_rt = empire_time(NULL);
 	putgame();
     }
 }
@@ -130,7 +131,7 @@ game_tick_tick(void)
     double dsecs, s_p_etu;
     int detu;
 
-    dsecs = time(NULL) - game->game_rt;
+    dsecs = empire_time(NULL) - game->game_rt;
     if (CANT_HAPPEN(dsecs < 0))
 	dsecs = 0;
     s_p_etu = secs_per_etu(game);
diff --git a/src/lib/common/wantupd.c b/src/lib/common/wantupd.c
index 07c3db0..03e3e0a 100644
--- a/src/lib/common/wantupd.c
+++ b/src/lib/common/wantupd.c
@@ -34,6 +34,7 @@
 #include <config.h>
 
 #include <time.h>
+#include "emptime.h"
 #include "file.h"
 #include "game.h"
 #include "misc.h"
@@ -102,7 +103,7 @@ demand_check(void)
 int
 demandupdatecheck(void)
 {
-    time_t now = time(NULL);
+    time_t now = empire_time(NULL);
 
     return update_demand == UPD_DEMAND_ASYNC
 	&& !updates_disabled()
diff --git a/src/lib/common/xdump.c b/src/lib/common/xdump.c
index 5d131c9..2ee5f79 100644
--- a/src/lib/common/xdump.c
+++ b/src/lib/common/xdump.c
@@ -77,6 +77,7 @@
 
 #include <ctype.h>
 #include <limits.h>
+#include "emptime.h"
 #include "file.h"
 #include "nat.h"
 #include "xdump.h"
@@ -263,7 +264,7 @@ xdhdr(struct xdstr *xd, char *name, int meta)
     } else
 	xd->pr("XDUMP %s%s %ld\n",
 	       meta ? "meta " : "",
-	       name, (long)time(NULL));
+	       name, (long)empire_time(NULL));
 }
 
 /*
diff --git a/src/lib/empthread/lwp.c b/src/lib/empthread/lwp.c
index b55f29b..9440a63 100644
--- a/src/lib/empthread/lwp.c
+++ b/src/lib/empthread/lwp.c
@@ -37,6 +37,7 @@
 #include <signal.h>
 #include <time.h>
 #include "empthread.h"
+#include "emptime.h"
 #include "misc.h"
 
 /* Flags that were passed to empth_init() */
@@ -136,7 +137,7 @@ empth_wait_for_signal(void)
     for (;;) {
 	err = lwpSigWait(&set, &sig);
 	if (CANT_HAPPEN(err)) {
-	    time(&now);
+	    empire_time(&now);
 	    lwpSleepUntil(now + 60);
 	    continue;
 	}
diff --git a/src/lib/empthread/ntthread.c b/src/lib/empthread/ntthread.c
index 4056c36..a4c4428 100644
--- a/src/lib/empthread/ntthread.c
+++ b/src/lib/empthread/ntthread.c
@@ -62,6 +62,7 @@
 #include "unistd.h"
 #include "misc.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "prototypes.h"
 #include "server.h"
 
@@ -637,7 +638,7 @@ empth_wakeup(empth_t *pThread)
 int
 empth_sleep(time_t until)
 {
-    long lSec = until - time(0) > 0 ? until - time(0) : 0;
+    long lSec = until - empire_time(0) > 0 ? until - empire_time(0) : 0;
     empth_t *pThread = TlsGetValue(dwTLSIndex);
     int iReturn = 0;
 
@@ -651,7 +652,7 @@ empth_sleep(time_t until)
 
 	loc_debug("sleep done. Waiting to run.");
 	loc_RunThisThread(NULL);
-    } while (!iReturn && ((lSec = until - time(0)) > 0));
+    } while (!iReturn && ((lSec = until - empire_time(0)) > 0));
 
     return iReturn;
 }
diff --git a/src/lib/empthread/pthread.c b/src/lib/empthread/pthread.c
index 3f56fbc..1a1078c 100644
--- a/src/lib/empthread/pthread.c
+++ b/src/lib/empthread/pthread.c
@@ -53,6 +53,7 @@
 
 #include "misc.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "prototypes.h"
 
 #define EMPTH_KILLED  1
@@ -378,10 +379,10 @@ empth_sleep(time_t until)
     struct timeval tv;
     int res;
 
-    empth_status("going to sleep %ld sec", until - time(0));
+    empth_status("going to sleep %ld sec", until - empire_time(0));
     pthread_mutex_unlock(&mtx_ctxsw);
     do {
-	tv.tv_sec = until - time(NULL);
+	tv.tv_sec = until - empire_time(NULL);
 	tv.tv_usec = 0;
 	res = select(0, NULL, NULL, NULL, &tv);
     } while (res < 0 && ctx->state == 0);
diff --git a/src/lib/gen/emptime.c b/src/lib/gen/emptime.c
new file mode 100644
index 0000000..855de99
--- /dev/null
+++ b/src/lib/gen/emptime.c
@@ -0,0 +1,51 @@
+/*
+ *  Empire - A multi-player, client/server Internet based war game.
+ *  Copyright (C) 1986-2008, Dave Pare, Jeff Bailey, Thomas Ruschak,
+ *                           Ken Stevens, Steve McClure
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *  ---
+ *
+ *  See files README, COPYING and CREDITS in the root of the source
+ *  tree for related information and legal notices.  It is expected
+ *  that future projects/authors will amend these files as needed.
+ *
+ *  ---
+ *
+ *  emptime.c: Time functions for regression testing and
+ *             replaying journals.
+ *
+ *  Known contributors to this file:
+ *     Ron Koenderink, 2008
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include "emptime.h"
+
+time_t
+emp_time(time_t * time_ptr, const char function[])
+{
+    static time_t now = (time_t)100L;
+
+    if (strcmp(function, "update_main") == 0)
+	now += 100L;
+
+    if (time_ptr != NULL)
+	*time_ptr = now;
+
+    return now;
+}
diff --git a/src/lib/gen/log.c b/src/lib/gen/log.c
index 7f57182..bc78466 100644
--- a/src/lib/gen/log.c
+++ b/src/lib/gen/log.c
@@ -41,6 +41,7 @@
 #include <sys/stat.h>
 #include <time.h>
 #include <unistd.h>
+#include "emptime.h"
 #include "misc.h"
 #include "optlist.h"
 #include "player.h"
@@ -116,7 +117,7 @@ logerror(char *format, ...)
     p[1] = 0;
     fputs(msg, stderr);
     if (logfd >= 0) {
-	time(&now);
+	empire_time(&now);
 	memcpy(buf, ctime(&now), ctime_len);
 	buf[ctime_len] = ' ';
 	write(logfd, buf, strlen(buf));
diff --git a/src/lib/lwp/sel.c b/src/lib/lwp/sel.c
index 2cafa08..988d091 100644
--- a/src/lib/lwp/sel.c
+++ b/src/lib/lwp/sel.c
@@ -39,6 +39,7 @@
 #include <sys/time.h>
 #include <time.h>
 #include <unistd.h>
+#include "emptime.h"
 #include "lwp.h"
 #include "lwpint.h"
 #include "prototypes.h"
@@ -144,7 +145,7 @@ lwpWakeupSleep(void)
     struct lwpProc *proc;
 
     if (LwpDelayq.head) {
-	now = time(NULL);
+	now = empire_time(NULL);
 	save.tail = save.head = 0;
 	while (NULL != (proc = lwpGetFirst(&LwpDelayq))) {
 	    if (now >= proc->runtime) {
@@ -175,7 +176,7 @@ lwpSleepUntil(time_t until)
     int res;
 
     lwpStatus(LwpCurrent, "sleeping for %ld sec",
-	      (long)(until - time(NULL)));
+	      (long)(until - empire_time(NULL)));
     LwpCurrent->runtime = until;
     if (LwpMaxfd == 0 && LwpDelayq.head == 0) {
 	/* select process is sleeping until first waiter arrives */
@@ -219,7 +220,7 @@ lwpSelect(void *arg)
 	tv.tv_sec = 1000000;
 	tv.tv_usec = 0;
 	if (LwpDelayq.head) {
-	    time(&now);
+	    empire_time(&now);
 	    proc = LwpDelayq.head;
 	    for (; proc != 0; proc = proc->next) {
 		delta = proc->runtime - now;
diff --git a/src/lib/player/accept.c b/src/lib/player/accept.c
index 3106849..726b5fc 100644
--- a/src/lib/player/accept.c
+++ b/src/lib/player/accept.c
@@ -45,6 +45,7 @@
 
 #include "empio.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "file.h"
 #include "misc.h"
 #include "nat.h"
@@ -91,7 +92,7 @@ player_new(int s)
 	emp_insque(&lp->queue, &Players);
 	lp->cnum = NATID_BAD;
 	lp->curid = -1;
-	time(&lp->curup);
+	empire_time(&lp->curup);
     }
     return lp;
 }
diff --git a/src/lib/player/player.c b/src/lib/player/player.c
index 0e1c5e3..9773db4 100644
--- a/src/lib/player/player.c
+++ b/src/lib/player/player.c
@@ -40,6 +40,7 @@
 #include "com.h"
 #include "empio.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "file.h"
 #include "journal.h"
 #include "misc.h"
@@ -64,7 +65,7 @@ player_main(struct player *p)
 
     p->state = PS_PLAYING;
     player = p;
-    time(&player->curup);
+    empire_time(&player->curup);
     update_timeused_login(player->curup);
     show_motd();
     if (init_nats() < 0) {
@@ -116,7 +117,7 @@ player_main(struct player *p)
     }
     /* #*# I put the following line in to prevent server crash -KHS */
     natp = getnatp(player->cnum);
-    time(&natp->nat_last_logout);
+    empire_time(&natp->nat_last_logout);
     putnat(natp);
     update_timeused(natp->nat_last_logout);
     enforce_minimum_session_time();
@@ -175,7 +176,7 @@ status(void)
     if (!(old_nstat & MONEY) && (player->nstat & MONEY))
 	pr("You are no longer broke!\n");
 
-    time(&player->curup);
+    empire_time(&player->curup);
     update_timeused(player->curup);
     if (natp->nat_stat == STAT_ACTIVE &&
 	natp->nat_timeused > m_m_p_d * 60) {
diff --git a/src/lib/player/recvclient.c b/src/lib/player/recvclient.c
index ab4ef69..8934189 100644
--- a/src/lib/player/recvclient.c
+++ b/src/lib/player/recvclient.c
@@ -35,6 +35,7 @@
 #include <config.h>
 
 #include "empio.h"
+#include "emptime.h"
 #include "journal.h"
 #include "player.h"
 #include "prototypes.h"
@@ -102,7 +103,7 @@ recvclient(char *cmd, int size)
 	     * check errors; oops once, then slow it down drastically.
 	     */
 	    CANT_HAPPEN(player->recvfail == 256);
-	    empth_sleep(time(NULL) + 60);
+	    empth_sleep(empire_time(NULL) + 60);
 	}
 	return player->eof ? -1 : -2;
     }
diff --git a/src/lib/subs/disloan.c b/src/lib/subs/disloan.c
index 9a6c670..9d7b6ba 100644
--- a/src/lib/subs/disloan.c
+++ b/src/lib/subs/disloan.c
@@ -46,6 +46,7 @@
 
 #include <config.h>
 
+#include "emptime.h"
 #include "file.h"
 #include "loan.h"
 #include "nat.h"
@@ -64,7 +65,7 @@ disloan(int n, struct lonstr *loan)
 	return 0;
     if (loan->l_loner != player->cnum && loan->l_lonee != player->cnum)
 	return 0;
-    (void)time(&now);
+    (void)empire_time(&now);
     pr("\nLoan #%d from %s to", n, cname(loan->l_loner));
     pr(" %s\n", cname(loan->l_lonee));
     if (loan->l_status == LS_PROPOSED) {
diff --git a/src/lib/subs/distrea.c b/src/lib/subs/distrea.c
index bfb182c..45f80ae 100644
--- a/src/lib/subs/distrea.c
+++ b/src/lib/subs/distrea.c
@@ -33,6 +33,7 @@
 
 #include <config.h>
 
+#include "emptime.h"
 #include "file.h"
 #include "nat.h"
 #include "player.h"
@@ -51,7 +52,7 @@ distrea(int n, struct trtstr *tp)
     if (tp->trt_cna != player->cnum &&
 	tp->trt_cnb != player->cnum && !player->god)
 	return 0;
-    (void)time(&now);
+    (void)empire_time(&now);
     if (now > tp->trt_exp) {
 	tp->trt_status = TS_FREE;
 	if (!puttre(n, tp)) {
diff --git a/src/lib/subs/journal.c b/src/lib/subs/journal.c
index 4f553c5..c8bb70c 100644
--- a/src/lib/subs/journal.c
+++ b/src/lib/subs/journal.c
@@ -57,6 +57,7 @@
 #include <time.h>
 #include "misc.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "journal.h"
 #include "optlist.h"
 #include "player.h"
@@ -83,7 +84,7 @@ journal_entry(char *fmt, ...)
     unsigned char *p;
 
     if (journal) {
-	time(&now);
+	empire_time(&now);
 	fprintf(journal, "%.24s %10.10s ",
 		ctime(&now), empth_name(empth_self()));
 
diff --git a/src/lib/subs/lostsub.c b/src/lib/subs/lostsub.c
index 2d0d046..8b2ea25 100644
--- a/src/lib/subs/lostsub.c
+++ b/src/lib/subs/lostsub.c
@@ -34,6 +34,7 @@
 
 #include <config.h>
 
+#include "emptime.h"
 #include "file.h"
 #include "lost.h"
 #include "misc.h"
@@ -124,7 +125,7 @@ findlost(short type, natid owner, short id, coord x, coord y, int free)
 void
 delete_old_lostitems(void)
 {
-    time_t expiry_time = time(NULL) - hours(lost_keep_hours);
+    time_t expiry_time = empire_time(NULL) - hours(lost_keep_hours);
     struct loststr lost;
     int i;
 
diff --git a/src/lib/subs/nreport.c b/src/lib/subs/nreport.c
index 2e83326..5600a5a 100644
--- a/src/lib/subs/nreport.c
+++ b/src/lib/subs/nreport.c
@@ -36,6 +36,7 @@
 
 #include <config.h>
 
+#include "emptime.h"
 #include "file.h"
 #include "nat.h"
 #include "news.h"
@@ -96,7 +97,7 @@ delete_old_news(void)
     struct nwsstr news;
 
     /* skip over expired news */
-    expiry_time = time(NULL) - days(news_keep_days);
+    expiry_time = empire_time(NULL) - days(news_keep_days);
     for (i = 0; getnews(i, &news); i++) {
 	if (news.nws_vrb == 0 || news.nws_when >= expiry_time)
 	    break;
@@ -156,7 +157,7 @@ ncache(int actor, int event, int victim, int times)
     int i;
     int oldslot;
     time_t oldtime;
-    time_t now = time(NULL);
+    time_t now = empire_time(NULL);
 
     oldslot = -1;
     oldtime = 0x7fffffff;
diff --git a/src/lib/subs/pr.c b/src/lib/subs/pr.c
index 628d831..44f03f0 100644
--- a/src/lib/subs/pr.c
+++ b/src/lib/subs/pr.c
@@ -55,6 +55,7 @@
 #include <stdlib.h>
 #include "com.h"
 #include "empio.h"
+#include "emptime.h"
 #include "file.h"
 #include "misc.h"
 #include "nat.h"
@@ -193,7 +194,7 @@ pr_wall(char *format, ...)
     struct player *p;
     va_list ap;
 
-    time(&now);
+    empire_time(&now);
     tm = localtime(&now);
     n = sprintf(buf, "BROADCAST from %s @ %02d:%02d: ",
 		getnatp(0)->nat_cnam, tm->tm_hour, tm->tm_min);
@@ -374,7 +375,7 @@ prmptrd(char *prompt, char *buf, int size)
     pr_id(player, C_FLUSH, "%s\n", prompt);
     if ((r = recvclient(buf, size)) < 0)
 	return r;
-    time(&player->curup);
+    empire_time(&player->curup);
     if (*buf == 0)
 	return 1;
     if (player->flags & PF_UTF8)
@@ -403,7 +404,7 @@ uprmptrd(char *prompt, char *buf, int size)
     pr_id(player, C_FLUSH, "%s\n", prompt);
     if ((r = recvclient(buf, size)) < 0)
 	return r;
-    time(&player->curup);
+    empire_time(&player->curup);
     if (*buf == 0)
 	return 1;
     if (player->flags & PF_UTF8)
@@ -419,7 +420,7 @@ prdate(void)
 {
     time_t now;
 
-    (void)time(&now);
+    (void)empire_time(&now);
     pr(ctime(&now));
 }
 
@@ -479,7 +480,7 @@ PRdate(natid cn)
 {
     time_t now;
 
-    (void)time(&now);
+    (void)empire_time(&now);
     PR(cn, ctime(&now));
 }
 
diff --git a/src/lib/subs/show.c b/src/lib/subs/show.c
index ac3125b..afb0e81 100644
--- a/src/lib/subs/show.c
+++ b/src/lib/subs/show.c
@@ -42,6 +42,7 @@
 #endif
 
 #include <math.h>
+#include "emptime.h"
 #include "file.h"
 #include "game.h"
 #include "item.h"
@@ -616,7 +617,7 @@ show_updates(int n)
     int demand = 0;
     int i;
 
-    pr("%s, Turn %d, ETU %d\n", fmttime2822(time(NULL)),
+    pr("%s, Turn %d, ETU %d\n", fmttime2822(empire_time(NULL)),
        game->game_turn, game->game_tick);
 
     if (update_time[0]) {
diff --git a/src/lib/subs/trechk.c b/src/lib/subs/trechk.c
index e77e2b0..84a78d1 100644
--- a/src/lib/subs/trechk.c
+++ b/src/lib/subs/trechk.c
@@ -41,6 +41,7 @@
 
 #include <config.h>
 
+#include "emptime.h"
 #include "file.h"
 #include "nat.h"
 #include "news.h"
@@ -65,7 +66,7 @@ trechk(natid actor, natid victim, int provision)
 
     if (!opt_TREATIES)
 	return 1;
-    (void)time(&now);
+    (void)empire_time(&now);
     broken = 0;
     applied = 0;
     for (cn = 0; cn < MAXNOC; cn++)
diff --git a/src/lib/subs/wu.c b/src/lib/subs/wu.c
index 5bcce21..c45d024 100644
--- a/src/lib/subs/wu.c
+++ b/src/lib/subs/wu.c
@@ -37,6 +37,7 @@
 #include <stdarg.h>
 #include <sys/uio.h>
 #include <unistd.h>
+#include "emptime.h"
 #include "file.h"
 #include "misc.h"
 #include "nat.h"
@@ -143,7 +144,7 @@ typed_wu(natid from, natid to, char *message, int type)
     }
     memset(&tel, 0, sizeof(tel));
     tel.tel_from = from;
-    (void)time(&tel.tel_date);
+    (void)empire_time(&tel.tel_date);
     len = strlen(message);
     if (CANT_HAPPEN(len > MAXTELSIZE)) {
 	len = MAXTELSIZE;
diff --git a/src/lib/update/anno.c b/src/lib/update/anno.c
index f07d441..1daf258 100644
--- a/src/lib/update/anno.c
+++ b/src/lib/update/anno.c
@@ -41,6 +41,7 @@
 #endif
 #include <stdio.h>
 #include <time.h>
+#include "emptime.h"
 #include "tel.h"
 #include "update.h"
 
@@ -60,7 +61,7 @@ delete_old_announcements(void)
     if (anno_keep_days < 0)
 	return;
 
-    time(&now);
+    empire_time(&now);
     old = now - days(anno_keep_days);
     logerror("Deleting annos older than %s", ctime(&old));
 
diff --git a/src/lib/update/main.c b/src/lib/update/main.c
index 32fa059..3ac6ce5 100644
--- a/src/lib/update/main.c
+++ b/src/lib/update/main.c
@@ -38,6 +38,7 @@
 
 #include "budg.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "game.h"
 #include "journal.h"
 #include "player.h"
@@ -64,7 +65,7 @@ update_main(void)
     struct natstr *np;
 
     logerror("production update (%d etus)", etu);
-    game_record_update(time(NULL));
+    game_record_update(empire_time(NULL));
     journal_update(etu);
 
     /* First, make sure all mobility is updated correctly. */
diff --git a/src/lib/update/mobility.c b/src/lib/update/mobility.c
index 95a81aa..674e999 100644
--- a/src/lib/update/mobility.c
+++ b/src/lib/update/mobility.c
@@ -35,6 +35,7 @@
 
 #include <config.h>
 
+#include "emptime.h"
 #include "game.h"
 #include "land.h"
 #include "plane.h"
@@ -130,7 +131,7 @@ mob_sect(void)
     int n, etus;
     time_t now;
 
-    time(&now);
+    empire_time(&now);
     for (n = 0; NULL != (sp = getsectid(n)); n++) {
 	sp->sct_timestamp = now;
 	if (opt_MOB_ACCESS)
@@ -167,7 +168,7 @@ mob_ship(void)
     int n, etus;
     time_t now;
 
-    time(&now);
+    empire_time(&now);
     for (n = 0; NULL != (sp = getshipp(n)); n++) {
 	sp->shp_timestamp = now;
 	if (opt_MOB_ACCESS)
@@ -202,7 +203,7 @@ mob_land(void)
     int n, etus;
     time_t now;
 
-    time(&now);
+    empire_time(&now);
     for (n = 0; NULL != (lp = getlandp(n)); n++) {
 	lp->lnd_timestamp = now;
 	if (opt_MOB_ACCESS)
@@ -251,7 +252,7 @@ mob_plane(void)
     int n, etus;
     time_t now;
 
-    time(&now);
+    empire_time(&now);
     for (n = 0; NULL != (pp = getplanep(n)); n++) {
 	pp->pln_timestamp = now;
 	if (opt_MOB_ACCESS)
diff --git a/src/server/main.c b/src/server/main.c
index 1f66f98..c887868 100644
--- a/src/server/main.c
+++ b/src/server/main.c
@@ -54,6 +54,7 @@
 
 #include "empio.h"
 #include "empthread.h"
+#include "emptime.h"
 #include "file.h"
 #include "journal.h"
 #include "land.h"
@@ -148,7 +149,7 @@ main(int argc, char **argv)
 #endif
     char *config_file = NULL;
     int op, idx, sig;
-    unsigned seed = time(NULL);
+    unsigned seed = empire_time(NULL);
 
     oops_handler = ignore;
 
diff --git a/src/server/marketup.c b/src/server/marketup.c
index 925c844..f684909 100644
--- a/src/server/marketup.c
+++ b/src/server/marketup.c
@@ -35,6 +35,7 @@
 #include <config.h>
 
 #include "empthread.h"
+#include "emptime.h"
 #include "file.h"
 #include "optlist.h"
 #include "player.h"
@@ -52,7 +53,7 @@ market_update(void *unused)
     player->god = 1;
 
     for (;;) {
-	time(&now);
+	empire_time(&now);
 	check_market();
 	check_trade();
 	now += 300;		/* Every 5 minutes */
diff --git a/src/server/shutdown.c b/src/server/shutdown.c
index 0bf3290..0ad337b 100644
--- a/src/server/shutdown.c
+++ b/src/server/shutdown.c
@@ -36,6 +36,7 @@
 
 #include <time.h>
 #include "empthread.h"
+#include "emptime.h"
 #include "file.h"
 #include "nat.h"
 #include "prototypes.h"
@@ -94,7 +95,7 @@ shutdown_sequence(void *unused)
 
     while (shutdown_pending > 0) {
 	--shutdown_pending;
-	time(&now);
+	empire_time(&now);
 	if (shutdown_pending <= 1440) {	/* one day */
 	    if (shutdown_pending == 0) {
 		shutdwn(0);
diff --git a/src/server/update.c b/src/server/update.c
index 28cb077..0521f6f 100644
--- a/src/server/update.c
+++ b/src/server/update.c
@@ -42,6 +42,7 @@
 #endif
 #include <time.h>
 #include "empthread.h"
+#include "emptime.h"
 #include "game.h"
 #include "misc.h"
 #include "optlist.h"
@@ -70,7 +71,7 @@ update_init(void)
     struct player *dp;
     int stacksize;
 
-    update_schedule_anchor = (time(NULL) + 59) / 60 * 60;
+    update_schedule_anchor = (empire_time(NULL) + 59) / 60 * 60;
     if (update_get_schedule() < 0)
 	exit(1);
 
@@ -98,7 +99,7 @@ update_init(void)
 static int
 update_get_schedule(void)
 {
-    time_t now = time(NULL);
+    time_t now = empire_time(NULL);
 
     if (read_schedule(schedulefil, update_time,
 		      sizeof(update_time) / sizeof(*update_time),
@@ -136,10 +137,10 @@ update_sched(void *unused)
 	} else {
 	    logerror("No update scheduled");
 	    /* want to sleep forever, but empthread doesn't provide that */
-	    while (empth_sleep(time(NULL) + (60 * 60 * 24)) >= 0) ;
+	    while (empth_sleep(empire_time(NULL) + (60 * 60 * 24)) >= 0) ;
 	}
 
-	now = time(NULL);
+	now = empire_time(NULL);
 	if (next_update != 0 && now >= next_update) {
 	    /* scheduled update time reached */
 	    if (now >= next_update + 60)
diff --git a/src/util/empsched.c b/src/util/empsched.c
index 1ac1cdc..d51694c 100644
--- a/src/util/empsched.c
+++ b/src/util/empsched.c
@@ -36,6 +36,7 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <time.h>
+#include "emptime.h"
 #include "optlist.h"
 #include "prototypes.h"
 #include "version.h"
@@ -102,7 +103,7 @@ main(int argc, char *argv[])
     else
 	in_file = argv[optind];
 
-    anchor = (time(NULL) + 59) / 60 * 60;
+    anchor = (empire_time(NULL) + 59) / 60 * 60;
     if (read_schedule(in_file, sched, n + 1, 0, anchor) < 0)
 	exit(1);
 
diff --git a/src/util/fairland.c b/src/util/fairland.c
index 77a5a53..ffdc5c5 100644
--- a/src/util/fairland.c
+++ b/src/util/fairland.c
@@ -70,6 +70,7 @@ static int quiet = 0;
 #include <stdarg.h>
 #include <stdio.h>
 #include <unistd.h>
+#include "emptime.h"
 #include "file.h"
 #include "misc.h"
 #include "nat.h"
@@ -183,7 +184,7 @@ main(int argc, char *argv[])
     int i = 0;
 
     program_name = argv[0];
-    rnd_seed = time(NULL);
+    rnd_seed = empire_time(NULL);
 
     while ((opt = getopt(argc, argv, "ae:hioqR:s:v")) != EOF) {
 	switch (opt) {
